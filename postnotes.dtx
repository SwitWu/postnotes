% \iffalse meta-comment
% \fi
%
% \iffalse
%<*driver>
\documentclass{l3doc}

% Have \GetFileInfo pick up date and version data and used in the
% documentation.
\usepackage{postnotes}

\begin{document}

\DocInput{postnotes.dtx}

\end{document}
%</driver>
%
% \fi
%
%
% \NewDocumentCommand\opt{m}{\texttt{#1}}
%
% \pdfstringdefDisableCommands{^^A
%   \def\opt#1{#1}
% }
%
%
% ^^A Have the Index at 'section' level rather than 'part'.  Otherwise it is
% ^^A just the same definition from 'l3doc.cls'.
% \IndexPrologue{^^A
%   \section*{Index}
%   \markboth{Index}{Index}
%   \addcontentsline{toc}{section}{Index}
%   The italic numbers denote the pages where the corresponding entry is
%   described, numbers underlined point to the definition, all others indicate
%   the places where it is used.^^A
% }
%
%
% \GetFileInfo{postnotes.sty}
%
% \title{^^A
%   The \pkg{postnotes} package^^A
%   \thanks{This file describes \fileversion, released \filedate.}^^A
%   \texorpdfstring{\\{}\medskip{}}{ - }^^A
%   Code documentation^^A
%   \texorpdfstring{\medskip{}}{}^^A
% }
%
% \author{^^A
%   Gustavo Barros^^A
%   \thanks{\url{https://github.com/gusbrs/postnotes}}^^A
% }
%
% \date{\filedate}
%
% \maketitle
%
%
% \tableofcontents
%
%
% \section{Initial setup}
% Start the \pkg{DocStrip} guards.
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% Identify the internal prefix (\LaTeX3 \pkg{DocStrip} convention).
%    \begin{macrocode}
%<@@=postnotes>
%    \end{macrocode}
%
%
%    \begin{macrocode}
\ProvidesExplPackage {postnotes} {2022-03-24} {0.1.0}
  {Endnotes for LaTeX}
%    \end{macrocode}
%
%
% \section{Plumbing}
%
%
% \subsection{Auxiliary}
%
%
% \begin{macro}{\@@_if_package_loaded:n}
%   Just a convenience, since frequently we just need one of the branches.
%    \begin{macrocode}
\prg_new_conditional:Npnn \@@_if_package_loaded:n #1 { T , F , TF }
  { \IfPackageLoadedTF {#1} { \prg_return_true: } { \prg_return_false: } }
%    \end{macrocode}
% \end{macro}
%
%
% \section{Data}
%
%    \begin{macrocode}
\int_new:N \g_@@_id_int
\tl_new:N \g_@@_theid_tl
\tl_gset:Nn \g_@@_theid_tl { \int_use:N \g_@@_id_int }
\seq_new:N \g_@@_queue_seq

% <note theid>
\cs_new:Npn \@@_data_name:n #1
  { g_@@_ #1 _data_prop }
\cs_generate_variant:Nn \@@_data_name:n { e }

% <note theid><note content>
\cs_new_protected:Npn \@@_store:nn #1#2
  {
    \prop_new:c { \@@_data_name:e {#1} }
    \prop_gput:cnn { \@@_data_name:e {#1} } { type } { note }
    \prop_gput:cnx { \@@_data_name:e {#1} } { mark } { \l_@@_mark_tl }
    \prop_gput:cnx { \@@_data_name:e {#1} } { sortnum }
      {
        \bool_if:NTF \l_@@_manual_sortnum_bool
          { \fp_use:N \l_@@_sort_num_fp }
          { \int_use:N \c@postnote }
      }
    \prop_gput:cnx { \@@_data_name:e {#1} } { thechapter } { \thechapter }
    \prop_gput:cnx { \@@_data_name:e {#1} } { thesection } { \thesection }
    \prop_gput:cnx { \@@_data_name:e {#1} } { pnsectlabel }
      { \g_@@_section_label_tl }
    \prop_gput:cnx { \@@_data_name:e {#1} } { pnsectid }
      { \int_use:N \g_@@_sectid_int }
    \prop_gput:cnn { \@@_data_name:e {#1} } { content } {#2}
  }

% <note theid><note content>
\cs_new_protected:Npn \@@_section_store:nn #1#2
  {
    \prop_new:c { \@@_data_name:e {#1} }
    \prop_gput:cnn { \@@_data_name:e {#1} } { type } { section }
    \prop_gput:cnx { \@@_data_name:e {#1} } { thechapter } { \thechapter }
    \prop_gput:cnx { \@@_data_name:e {#1} } { thesection } { \thesection }
    \prop_gput:cnx { \@@_data_name:e {#1} } { pnsectid }
      { \int_use:N \g_@@_sectid_int }
    \prop_gput:cnn { \@@_data_name:e {#1} } { content } {#2}
  }


% <theid><prop><tl var>
\cs_new_protected:Npn \@@_prop_get:nnN #1#2#3
  {
    \prop_get:cnNF { \@@_data_name:e {#1} } {#2} #3
      { \tl_clear:N #3 }
  }
% <theid><prop>
\cs_new:Npn \@@_prop_item:nn #1#2
  { \prop_item:cn { \@@_data_name:e {#1} } {#2} }
% <theid>
\cs_new_protected:Npn \@@_prop_gclear:n #1
  { \prop_gclear:c { \@@_data_name:e {#1} } }

\tl_const:Nn \c_@@_ref_prefix_tl { postnote@r }
\cs_new_protected:Npx \post@note
  { \exp_not:N \@newl@bel { \c_@@_ref_prefix_tl } }

\cs_new_protected:Npn \@@_set_mark_page_label:n #1
  {
    \iow_shipout_x:Nn \@auxout
      { \post@note { mark@ #1 } { \thepage } }
  }
\cs_generate_variant:Nn \@@_set_mark_page_label:n { x }
\cs_new_protected:Npn \@@_set_text_page_label:n #1
  {
    \iow_shipout_x:Nn \@auxout
      { \post@note { text@ #1 } { \int_use:N \c@page } }
  }
\cs_generate_variant:Nn \@@_set_text_page_label:n { x }
\cs_new_protected:Npn \@@_set_print_page_label:n #1
  {
    \iow_shipout_x:Nn \@auxout
      { \post@note { print@ #1 } { \int_use:N \c@page } }
  }
\cs_generate_variant:Nn \@@_set_print_page_label:n { x }

\cs_new_protected:Npn \@@_get_pageref:Nn #1#2
  {
    \cs_if_exist:cTF { \c_@@_ref_prefix_tl @ #2 }
      { \tl_set:Nv #1 { \c_@@_ref_prefix_tl @ #2 } }
      { \tl_clear:N #1 }
  }
\cs_generate_variant:Nn \@@_get_pageref:Nn { Nx }
\cs_new:Npn \@@_extract_pageref:n #1
  {
    \cs_if_exist:cTF { \c_@@_ref_prefix_tl @ #1 }
      { \exp_not:v { \c_@@_ref_prefix_tl @ #1 } }
      { \c_empty_tl }
  }
\cs_generate_variant:Nn \@@_extract_pageref:n { e }
%    \end{macrocode}
%
%
% \section{Options}
%
% \subsection{TODO}
%
%    \begin{macrocode}
\tl_new:N \l_@@_list_env_tl
\tl_set:Nn \l_@@_list_env_tl { enumerate }

\tl_new:N \l_@@_print_format_tl
\tl_set:Nn \l_@@_print_format_tl { \small }
%    \end{macrocode}
%
% \subsection*{\opt{heading} option}
%
%    \begin{macrocode}
\keys_define:nn { postnotes/print }
  {
    heading .cs_set_protected:Np = \pnheading ,
    heading .value_required:n = true ,
  }
\cs_if_exist:cTF { chapter }
  {
    \cs_new_protected:Npn \pnheading
      {
        % TODO This value is just for testing, set better default later.
        \cleardoublepage{}
        % \markright{\pnHeaderChapsPages}
        \markright{\pnheaderdefault}
        \chapter{\pntitle}
        % \@mkboth{\pnHeaderChapsPages}{\pnHeaderChapsPages}
        \@mkboth{\pnheaderdefault}{\pnheaderdefault}
        % \markboth{\pnHeaderChapsPages}{\pnHeaderChapsPages}
        \thispagestyle{headings}
      }
  }
  {
    \cs_new_protected:Npn \pnheading
      {
        \section*{\pntitle}
        \@mkboth{\pnheaderdefault}{\pnheaderdefault}
      }
  }
%    \end{macrocode}
%
%
%    \begin{macrocode}
\tl_new:N \pntitle
\tl_new:N \pnhdnotes
\tl_new:N \pnhdtopage
\tl_new:N \pnhdtopages
\tl_set:Nn \pntitle     { Notes }
\tl_set:Nn \pnhdnotes   { Notes }
\tl_set:Nn \pnhdtopage  { to~page }
\tl_set:Nn \pnhdtopages { to~pages }
%    \end{macrocode}
%
%
% \subsection*{\opt{hyperref} and \opt{backref} options}
%
%    \begin{macrocode}
\bool_new:N \l_@@_hyperlink_bool
\bool_new:N \l_@@_hyperref_warn_bool
\bool_new:N \l_@@_backref_bool
\keys_define:nn { postnotes/preamble }
  {
    hyperref .choice: ,
    hyperref / auto .code:n =
      {
        \bool_set_true:N \l_@@_hyperlink_bool
        \bool_set_false:N \l_@@_hyperref_warn_bool
      } ,
    hyperref / true .code:n =
      {
        \bool_set_true:N \l_@@_hyperlink_bool
        \bool_set_true:N \l_@@_hyperref_warn_bool
      } ,
    hyperref / false .code:n =
      {
        \bool_set_false:N \l_@@_hyperlink_bool
        \bool_set_false:N \l_@@_hyperref_warn_bool
      } ,
    hyperref .initial:n = auto ,
    hyperref .default:n = true ,
    backref .bool_set:N = \l_@@_backref_bool ,
    backref .initial:n = true ,
    backref .default:n = true ,
  }
%    \end{macrocode}
%
%    \begin{macrocode}
\msg_new:nnn { postnotes } { option-preamble-only }
  { Option~'#1'~only~available~in~the~preamble~\msg_line_context:. }
\msg_new:nnn { postnotes } { missing-hyperref }
  { Missing~'hyperref'~package.~Setting~'hyperref=false'. }
\AddToHook { begindocument }
  {
    \@@_if_package_loaded:nF { hyperref }
      {
        \bool_if:NT \l_@@_hyperref_warn_bool
          { \msg_warning:nn { postnotes } { missing-hyperref } }
        \bool_set_false:N \l_@@_hyperlink_bool
      }
    \keys_define:nn { postnotes/setup }
      {
        hyperref .code:n =
          {
            \msg_warning:nnn { postnotes }
              { option-preamble-only } { hyperref }
          } ,
        backref .code:n =
          {
            \msg_warning:nnn { postnotes }
              { option-preamble-only } { backref }
          } ,
      }
  }
%    \end{macrocode}
%
%
% \subsection*{\opt{sort} option}
%
%    \begin{macrocode}
\bool_new:N \l_@@_sort_bool
\keys_define:nn { postnotes/print }
  {
    sort .bool_set:N = \l_@@_sort_bool ,
    sort .initial:n = true ,
    sort .default:n = true ,
  }
%    \end{macrocode}
%
%
% \subsection{\cs{postnotesetup}}
%
%
% \begin{macro}[int]{\postnotesetup}
%   Provide \cs{postnotesetup}.
%   \begin{syntax}
%     \cs{postnotesetup}\marg{options}
%   \end{syntax}
%    \begin{macrocode}
\NewDocumentCommand \postnotesetup { m }
  { \@@_setup:n {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_setup:n}
%   A version of \cs{postnotesetup} for internal use.
%   \begin{syntax}
%     \cs{@@_setup:n}\marg{options}
%   \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_setup:n #1
  { \keys_set:nn { postnotes/setup } {#1} }
%    \end{macrocode}
% \end{macro}
%
% \subsubsection*{Package options}
%
%    \begin{macrocode}
\keys_define:nn { }
  {
    postnotes/setup .inherit:n =
      {
        postnotes/preamble ,
        postnotes/print ,
      }
  }
%    \end{macrocode}
%
% \section{\cs{postnote}}
%
% Different from the traditional \cs{footnotemark} / \cs{footnotetext} system,
% in the context of endnotes, the functionality which corresponds to
% \cs{footnotetext} is simply to store the data to be typeset later.  Hence,
% some of the problems that afflict footnotes do not apply to endnotes.
% Namely, they can be used in ``inner paragraph mode'' (\cs{mbox} etc.), and
% if the ``text'' will be typeset in the same page as the ``mark'' is of
% little concern.
%
% Therefore, the separation between ``mark'' and ``text'' is of little use for
% endnotes and, that given, the ability to set an arbitrary ``mark'' value is
% less important, even if it has a place.  And, since they introduce their own
% set of problems, and quite ponderous ones, we are better off curbing some of
% this heritage.
%
% One relevant issue that potentially requires some manual adjustment, just as
% they do for \cs{footnotes}, are floats and their ability to wreak havoc in
% an otherwise so well behaved order of counters.  If we received an arbitrary
% number, as the kernel functionality for footnotes and other endnotes
% packages do, this value is expected to the printed as such, hence it must
% correspond to the \texttt{postnote} counter.  But this counter is in the
% hands of the user, and can be reset along the document, thus its uniqueness
% cannot be ensured.  Besides, there might be a need for a mark to be an
% arbitrary token list, rather than a number.  For example, a critical edition
% where the original order of notes cannot be disturbed, and editor notes have
% to be intercalated among the original ones.  The kernel footnote structure
% does not support this (the optional argument must be a number), but it would
% be interesting if we could.  The best idea I came up with is to enjoy
% ``modernity'' and leverage a keyval set of options: \opt{mark}, receiving an
% arbitrary token list, and \opt{sortnum}, receiving a floating point number.
% The pair makes for well defined mark and print order.  And it also covers
% the case of floats, even if they might also need an ocasional
% \texttt{\cs{addtocounter}\{postnote\}}.
%
% We don't offer \cs{footnotetext} at all.  But, we offer a stripped down
% version of \cs{footnotemark}, to enable users to have multiple marks for the
% same note.  It receives only an optional argument which is a note offset,
% and can only receive non-negative values and refer to previously added
% notes.
%
% David Carlisle and Ulrike Fischer shared some thoughts on the matter on the
% TeX.SX chat:
% \url{https://chat.stackexchange.com/transcript/message/60754383#60754383}.
%
%

%    \begin{macrocode}
\newcounter { postnote }


\NewDocumentCommand \postnote { O { } m }
  { \@@_note:nn {#1} {#2} }

% <options (currently just the mark)><note content>
\cs_new_protected:Npn \@@_note:nn #1#2
  {
    \group_begin:
    \keys_set:nn { postnotes/note } {#1}
    \int_gincr:N \g_@@_id_int
    \seq_gput_right:Nx \g_@@_queue_seq { \g_@@_theid_tl }
    \tl_if_empty:NT \l_@@_mark_tl
      {
        % For why I'm setting \theHpostnote locally instead of globally, see
        % https://github.com/latex3/hyperref/issues/230, thanks Ulrike
        % Fischer.  The alternative would be to not use \refstepcounter, set
        % the anchor manually in \@@_typeset_mark:nn, and define
        % \@currentlabel and \@currentcounter manually.  I don't see how I
        % could apply the first two of Ulrike's suggestions here, the third
        % would cost storing an additional variable and added complexity.  I
        % have the ID and want to retrieve a reliable destination name on the
        % other side.  And it is '\theH<counter>' which \refstepcounter uses
        % to define the anchor, so I set it directly.
        \cs_set:Npx \theHpostnote { \g_@@_theid_tl .mark }
        \refstepcounter { postnote }
        \tl_set:Nx \l_@@_mark_tl { \thepostnote }
      }
    \@@_set_mark_page_label:x { \g_@@_theid_tl }
    \@@_typeset_mark:xV { \g_@@_theid_tl } \l_@@_mark_tl
    \@@_store:nn { \g_@@_theid_tl } {#2}
    \group_end:
  }

\tl_new:N \l_@@_mark_tl
\fp_new:N \l_@@_sort_num_fp
\bool_new:N \l_@@_manual_sortnum_bool
\keys_define:nn { postnotes/note }
  {
    mark .tl_set:N = \l_@@_mark_tl ,
    mark .value_required:n = true ,
    sortnum .code:n =
      {
        \fp_set:Nn \l_@@_sort_num_fp {#1}
        \bool_set_true:N \l_@@_manual_sortnum_bool
      } ,
    sortnum .value_required:n = true ,
  }


% <theid><mark>
\cs_new_protected:Npn \@@_typeset_mark:nn #1#2
  {
    \@@_typeset_mark_wrapper:n
      {
        \bool_if:NTF \l_@@_hyperlink_bool
          { \hyperlink { postnote. #1 .text } { \@@_make_mark:n {#2} } }
          { \@@_make_mark:n {#2} }
      }
  }
\cs_generate_variant:Nn \@@_typeset_mark:nn { xV }


% From the definition of \cs{@footnotemark} in the kernel.
\tl_new:N \l_@@_saved_spacefactor_tl
% <mark>
\cs_new_protected:Npn \@@_typeset_mark_wrapper:n #1
  {
    \mode_leave_vertical:
    \if_mode_horizontal:
    \tl_set:Nx \l_@@_saved_spacefactor_tl { \the\spacefactor }
    \nobreak
    \fi:
    #1
    \if_mode_horizontal:
    \spacefactor \l_@@_saved_spacefactor_tl
    \fi:
    \scan_stop:
  }
% From the default definition of \cs{@makefnmark} in the kernel.
\cs_new_protected:Npn \@@_make_mark:n #1
  { \hbox:n { \@textsuperscript { \normalfont #1 } } }


\NewDocumentCommand \postnoterefmark { m }
  { \@@_ref_mark:n {#1} }

\cs_new_protected:Npn \@@_ref_mark:n #1
  {
    \group_begin:
    \@@_typeset_mark_wrapper:n
      {
        \bool_if:NTF \l_@@_hyperlink_bool
          { \hyperref [#1] { \@@_make_mark:n { \ref*{#1} } } }
          {
            \@@_if_package_loaded:nT { hyperref }
              { \@@_make_mark:n { \ref*{#1} } }
              { \@@_make_mark:n { \ref{#1} } }
          }
      }
    \group_end:
  }

\AddToHook { package/zref-user/after }
  {
    \NewDocumentCommand \postnotezrefmark { m }
      { \@@_zref_mark:n {#1} }
    \cs_new_protected:Npn \@@_zref_mark:n #1
      {
        \group_begin:
        \@@_typeset_mark_wrapper:n
          {
            \bool_if:NTF \l_@@_hyperlink_bool
              { \hyperref [#1] { \@@_make_mark:n { \zref{#1} } } }
              { \@@_make_mark:n { \zref{#1} } }
          }
        \group_end:
      }
  }
%    \end{macrocode}
%
%
% \section{\cs{postnotesection}}
%
%    \begin{macrocode}
\int_new:N \g_@@_sectid_int

\NewDocumentCommand \postnotesection { O { } m }
  { \@@_section:nn {#1} {#2} }

\cs_new_protected:Npn \@@_section:nn #1#2
  {
    \int_gincr:N \g_@@_id_int
    \int_gincr:N \g_@@_sectid_int
    \seq_gput_right:Nx \g_@@_queue_seq { \g_@@_theid_tl }
    \tl_gclear:N \g_@@_section_label_tl
    \keys_set:nn { postnotes/section } {#1}
    \@@_section_store:nn { \g_@@_theid_tl } {#2}
  }

\tl_new:N \g_@@_section_label_tl
\keys_define:nn { postnotes/section }
  {
    label .tl_gset:N = \g_@@_section_label_tl ,
    label .value_required:n = true ,
  }

%    \end{macrocode}
%
%
% \section{\cs{printpostnotes}}
%
%    \begin{macrocode}
\NewDocumentCommand \printpostnotes { O { } }
  { \@@_print_notes:n {#1} }

\int_new:N \g_@@_print_postnotes_int
\tl_new:N \l_@@_print_theid_tl
\tl_new:N \l_@@_print_theid_next_tl
\tl_new:N \l_@@_print_mark_tl
\tl_new:N \l_@@_print_sectid_tl
\tl_new:N \l_@@_print_type_curr_tl
\tl_new:N \l_@@_print_type_next_tl
\tl_new:N \l_@@_print_type_prev_tl
\tl_new:N \l_@@_print_content_tl
\tl_new:N \pnthechapter
\tl_new:N \pnthesection
\tl_new:N \pnthepage
\tl_new:N \pnthechapternextnote
\tl_new:N \pnthesectionnextnote

\newcounter { postnotesection }

\cs_new_protected:Npn \@@_print_notes:n #1
  {
    \group_begin:
    \int_gincr:N \g_@@_print_postnotes_int
    \tl_set:Nn \l_@@_print_type_prev_tl { open }
    \seq_if_empty:NF \g_@@_queue_seq
      {
        \pnheading
        \AddToHook { shipout/before } [ postnotes/header ]
          { \@@_set_headers_vars_next: }
        % Let biblatex know we are in a 'notes' context.
        \@@_if_package_loaded:nT { biblatex }
          { \toggletrue { blx@footnote } }
        \bool_if:NT \l_@@_sort_bool
          { \@@_sort_queue:N \g_@@_queue_seq }
        \@@_get_headers_data:N \g_@@_queue_seq
        \@@_set_headers_vars_first:
      }
    \bool_until_do:nn { \seq_if_empty_p:N \g_@@_queue_seq }
      {
        \seq_gpop_left:NN \g_@@_queue_seq \l_@@_print_theid_tl
        \@@_prop_get:nnN { \l_@@_print_theid_tl }
          { type } \l_@@_print_type_curr_tl
        \seq_if_empty:NTF \g_@@_queue_seq
          {
            \tl_set:Nn \l_@@_print_theid_next_tl { noid }
            \tl_set:Nn \l_@@_print_type_next_tl { close }
          }
          {
            \seq_get_left:NN \g_@@_queue_seq \l_@@_print_theid_next_tl
            \@@_prop_get:nnN { \l_@@_print_theid_next_tl }
              { type } \l_@@_print_type_next_tl
          }
        \tl_if_eq:NnTF \l_@@_print_type_curr_tl { section }
          {
            % type_curr = 'section'
            % We only process the entry if type_next is 'note': here are
            % skipped empty sections.
            \tl_if_eq:NnT \l_@@_print_type_next_tl { note }
              {
                \group_begin:
                \@@_prop_get:nnN { \l_@@_print_theid_tl }
                  { thechapter } \pnthechapter
                \@@_prop_get:nnN { \l_@@_print_theid_tl }
                  { thesection } \pnthesection
                \@@_prop_get:nnN { \l_@@_print_theid_next_tl }
                  { thechapter } \pnthechapternextnote
                \@@_prop_get:nnN { \l_@@_print_theid_next_tl }
                  { thesection } \pnthesectionnextnote
                \@@_prop_get:nnN { \l_@@_print_theid_tl }
                  { pnsectid } \l_@@_print_sectid_tl
                \exp_args:Nnx \setcounter { postnotesection }
                  { \int_eval:n { \l_@@_print_sectid_tl } }
                \@@_prop_get:nnN { \l_@@_print_theid_tl }
                  { content } \l_@@_print_content_tl
                \l_@@_print_content_tl
                \group_end:
                % Set type_prev for the next iteration.
                \tl_set:NV \l_@@_print_type_prev_tl
                  \l_@@_print_type_curr_tl
              }
          }
          {
            % type_curr = 'note'
            \tl_if_eq:NnF \l_@@_print_type_prev_tl { note }
              {
                \exp_args:Nx \begin { \l_@@_list_env_tl }
                \l_@@_print_format_tl
              }
            \group_begin:
            \@@_get_pageref:Nx \pnthepage
              { mark@ \l_@@_print_theid_tl }
            \@@_prop_get:nnN { \l_@@_print_theid_tl }
              { mark } \l_@@_print_mark_tl
            \@@_prop_get:nnN { \l_@@_print_theid_tl }
              { content } \l_@@_print_content_tl
            \cs_set:Npn \@currentcounter { postnote }
            \cs_set:Npx \@currentlabel
              { \p@postnote \l_@@_print_mark_tl }
            \cs_set:Npx \@currentHref
              { postnote. \l_@@_print_theid_tl .text }
            \item
              [
                \@@_set_text_page_label:x { \l_@@_print_theid_tl }
                \@@_typeset_text_mark:eV
                  { \l_@@_print_theid_tl }
                  \l_@@_print_mark_tl
              ]
            \l_@@_print_content_tl
            \group_end:
            \tl_if_eq:NnF \l_@@_print_type_next_tl { note }
              { \exp_args:Nx \end { \l_@@_list_env_tl } }
            % Set type_prev for the next iteration.
            \tl_set:NV \l_@@_print_type_prev_tl
              \l_@@_print_type_curr_tl
          }
        % I'm not sure there's much gain in clearing the variable, but we
        % won't use it anymore, so it doesn't harm to spare some bits/cycles.
        \@@_prop_gclear:n { \l_@@_print_theid_tl }
      }
    \AddToHookNext { shipout/after }
      { \RemoveFromHook { shipout/before } [ postnotes/header ] }
    \group_end:
  }

\cs_new:Npn \@@_make_text_mark:n #1 { #1 . }
\cs_new_protected:Npn \@@_set_hyper_anchor:n #1
  { \Hy@raisedlink { \hyper@anchor {#1} } }
\cs_new:Npn \@@_typeset_text_mark:nn #1#2
  {
    \bool_if:NTF \l_@@_hyperlink_bool
      {
        \@@_set_hyper_anchor:n { postnote. #1 .text }
        \bool_if:NTF \l_@@_backref_bool
          { \hyperlink { postnote. #1 .mark } { \@@_make_text_mark:n {#2} } }
          { \@@_make_text_mark:n {#2} }
      }
      { \@@_make_text_mark:n {#2} }
  }
\cs_generate_variant:Nn \@@_typeset_text_mark:nn {eV}
%    \end{macrocode}
%
%
% \section{Sorting}
%
%    \begin{macrocode}
\cs_new_protected:Npn \@@_sort_queue:N #1 % \g_@@_queue_seq
  {
    \group_begin:
    \seq_gsort:Nn #1
      {
        \@@_prop_get:nnN {##1} { pnsectid } \l_tmpa_tl
        \@@_prop_get:nnN {##2} { pnsectid } \l_tmpb_tl
        \tl_if_eq:NNTF \l_tmpa_tl \l_tmpb_tl
          {
            \@@_prop_get:nnN {##1} { type } \l_tmpa_tl
            \@@_prop_get:nnN {##2} { type } \l_tmpb_tl
            \bool_lazy_and:nnTF
              { \str_if_eq_p:Vn \l_tmpa_tl { note } }
              { \str_if_eq_p:Vn \l_tmpb_tl { note } }
              {
                \@@_prop_get:nnN {##1} { sortnum } \l_tmpa_tl
                \@@_prop_get:nnN {##2} { sortnum } \l_tmpb_tl
                \fp_compare:nNnTF { \l_tmpa_tl } > { \l_tmpb_tl }
                  { \sort_return_swapped: }
                  { \sort_return_same:    }
              }
              { \sort_return_same: }
          }
          { \sort_return_same: }
      }
    \group_end:
  }
%    \end{macrocode}
%
%
% \section{Headers}
%
%    \begin{macrocode}
\tl_new:N \pnhdpagefirst
\tl_new:N \pnhdpagelast
\tl_new:N \pnhdchapfirst
\tl_new:N \pnhdchaplast
\tl_new:N \pnhdsectfirst
\tl_new:N \pnhdsectlast
\tl_new:N \pnhdlabelfirst
\tl_new:N \pnhdlabellast
\prop_new:N \g_@@_header_page_first_prop
\prop_new:N \g_@@_header_page_last_prop
\prop_new:N \g_@@_header_chap_first_prop
\prop_new:N \g_@@_header_chap_last_prop
\prop_new:N \g_@@_header_sect_first_prop
\prop_new:N \g_@@_header_sect_last_prop
\prop_new:N \g_@@_header_label_first_prop
\prop_new:N \g_@@_header_label_last_prop
\tl_new:N \g_@@_header_prev_last_page_tl
\tl_new:N \g_@@_header_prev_last_chap_tl
\tl_new:N \g_@@_header_prev_last_sect_tl
\tl_new:N \g_@@_header_prev_last_label_tl
\tl_new:N \l_@@_prev_text_page_tl
\tl_new:N \l_@@_curr_text_page_tl
\tl_new:N \l_@@_prev_mark_page_tl
\tl_new:N \l_@@_prev_mark_chap_tl
\tl_new:N \l_@@_prev_mark_sect_tl
\tl_new:N \l_@@_prev_mark_label_tl
\cs_new_protected:Npn \@@_get_headers_data:N #1 % \g_@@_queue_seq
  {
    \group_begin:
    \tl_gclear:N \pnhdpagefirst
    \tl_gclear:N \pnhdpagelast
    \tl_gclear:N \pnhdchapfirst
    \tl_gclear:N \pnhdchaplast
    \tl_gclear:N \pnhdsectfirst
    \tl_gclear:N \pnhdsectlast
    \tl_gclear:N \pnhdlabelfirst
    \tl_gclear:N \pnhdlabellast
    \prop_gclear:N \g_@@_header_page_first_prop
    \prop_gclear:N \g_@@_header_page_last_prop
    \prop_gclear:N \g_@@_header_chap_first_prop
    \prop_gclear:N \g_@@_header_chap_last_prop
    \prop_gclear:N \g_@@_header_sect_first_prop
    \prop_gclear:N \g_@@_header_sect_last_prop
    \prop_gclear:N \g_@@_header_label_first_prop
    \prop_gclear:N \g_@@_header_label_last_prop
    \tl_gclear:N \g_@@_header_prev_last_page_tl
    \tl_gclear:N \g_@@_header_prev_last_chap_tl
    \tl_gclear:N \g_@@_header_prev_last_sect_tl
    \tl_gclear:N \g_@@_header_prev_last_label_tl
    \tl_clear:N \l_@@_prev_text_page_tl
    \tl_clear:N \l_@@_curr_text_page_tl
    \tl_clear:N \l_@@_prev_mark_page_tl
    \tl_clear:N \l_@@_prev_mark_chap_tl
    \tl_clear:N \l_@@_prev_mark_sect_tl
    \tl_clear:N \l_@@_prev_mark_label_tl
    \seq_map_inline:Nn #1
      {
        \exp_args:Nx \tl_if_eq:nnT
          { \@@_prop_item:nn {##1} { type } }
          { note }
          {
            \@@_get_pageref:Nn \l_@@_curr_text_page_tl { text@ ##1 }
            \tl_if_empty:NF \l_@@_curr_text_page_tl
              {
                \tl_if_eq:NNTF
                  \l_@@_prev_text_page_tl
                  \l_@@_curr_text_page_tl
                  {
                    % we are in the same page as the previous note, just store
                    % the 'prev_mark' data.
                    \@@_get_pageref:Nn
                      \l_@@_prev_mark_page_tl { mark@ ##1 }
                    \@@_prop_get:nnN {##1} { thechapter }
                      \l_@@_prev_mark_chap_tl
                    \@@_prop_get:nnN {##1} { thesection }
                      \l_@@_prev_mark_sect_tl
                    \@@_prop_get:nnN {##1} { pnsectlabel }
                      \l_@@_prev_mark_label_tl
                  }
                  {
                    % We are in the transition of pages (or in the very first
                    % note, given \l_@@_prev_text_page_tl is initialized to
                    % empty).

                    % Set 'first' values for current page, based on the
                    % current note id.
                    \prop_gput:Nxx \g_@@_header_page_first_prop
                      { \l_@@_curr_text_page_tl }
                      { \@@_extract_pageref:n { mark@ ##1 } }
                    \prop_gput:Nxx \g_@@_header_chap_first_prop
                      { \l_@@_curr_text_page_tl }
                      { \@@_prop_item:nn {##1} { thechapter } }
                    \prop_gput:Nxx \g_@@_header_sect_first_prop
                      { \l_@@_curr_text_page_tl }
                      { \@@_prop_item:nn {##1} { thesection } }
                    \prop_gput:Nxx \g_@@_header_label_first_prop
                      { \l_@@_curr_text_page_tl }
                      { \@@_prop_item:nn {##1} { pnsectlabel } }

                    % Set 'last' values for previous page, based on the stored
                    % above (on the T branch).  There is no previous page to
                    % the first one of \printpostnotes (so we don't set 'last'
                    % values for it, conditioning on \l_@@_prev_text_page_tl
                    % being empty, which only occurs on the first note).
                    \tl_if_empty:NF \l_@@_prev_text_page_tl
                      {
                        \prop_gput:Nxx \g_@@_header_page_last_prop
                          { \l_@@_prev_text_page_tl }
                          { \l_@@_prev_mark_page_tl }
                        \prop_gput:Nxx \g_@@_header_chap_last_prop
                          { \l_@@_prev_text_page_tl }
                          { \l_@@_prev_mark_chap_tl }
                        \prop_gput:Nxx \g_@@_header_sect_last_prop
                          { \l_@@_prev_text_page_tl }
                          { \l_@@_prev_mark_sect_tl }
                        \prop_gput:Nxx \g_@@_header_label_last_prop
                          { \l_@@_prev_text_page_tl }
                          { \l_@@_prev_mark_label_tl }
                      }

                    % Set \l_@@_prev_text_page_tl for the next iteration
                    % (\l_@@_curr_text_page_tl is never empty at this point,
                    % since we conditioned to it).
                    \tl_set:NV \l_@@_prev_text_page_tl
                      \l_@@_curr_text_page_tl
                  }
              }
          }
      }

    % We can't catch the transition from the last page of \printpostnotes to
    % the following one through the mapping above, but the 'prev_mark' values
    % of the last note in the loop are the ones we want, so we set 'last'
    % values for the last page based on them.
    \tl_if_empty:NF \l_@@_prev_text_page_tl
      {
        \prop_gput:Nxx \g_@@_header_page_last_prop
          { \l_@@_prev_text_page_tl }
          { \l_@@_prev_mark_page_tl }
        \prop_gput:Nxx \g_@@_header_chap_last_prop
          { \l_@@_prev_text_page_tl }
          { \l_@@_prev_mark_chap_tl }
        \prop_gput:Nxx \g_@@_header_sect_last_prop
          { \l_@@_prev_text_page_tl }
          { \l_@@_prev_mark_sect_tl }
        \prop_gput:Nxx \g_@@_header_label_last_prop
          { \l_@@_prev_text_page_tl }
          { \l_@@_prev_mark_label_tl }
      }
    \group_end:
  }

% The sequence of pages processed in \cs{@@_get_headers_data:N} is not ensured
% to be continuous, since not every page of \cs{printpostnotes} starts a
% note.  There may be notes that fill whole pages, or the last page of the
% notes may end with a note that started on the penultimate page.  We must
% handle this case at this point.  For every page for which there is
% information provided by \cs{@@_get_headers_data:N} we store a
% 'header_prev_last' (the last value of the previous header) for each of the
% variables of interest.  If the next page is skipped in the sequence (no
% notes starting on it), we can use these stored values to set both 'first'
% and 'last' variables based on them for that page.
\cs_new_protected:Npn \@@_set_headers_vars:n #1
  {
    \group_begin:
    \prop_get:NnNTF \g_@@_header_page_first_prop
      {#1} \l_tmpa_tl
      { \tl_gset:NV \pnhdpagefirst \l_tmpa_tl }
      { \tl_gset:NV \pnhdpagefirst \g_@@_header_prev_last_page_tl }
    \prop_get:NnNTF \g_@@_header_page_last_prop
      {#1} \l_tmpa_tl
      {
        \tl_gset:NV \pnhdpagelast \l_tmpa_tl
        \tl_gset:NV \g_@@_header_prev_last_page_tl \l_tmpa_tl
      }
      { \tl_gset:NV \pnhdpagelast \g_@@_header_prev_last_page_tl }
    \prop_get:NnNTF \g_@@_header_chap_first_prop
      {#1} \l_tmpa_tl
      { \tl_gset:NV \pnhdchapfirst \l_tmpa_tl }
      { \tl_gset:NV \pnhdchapfirst \g_@@_header_prev_last_chap_tl }
    \prop_get:NnNTF \g_@@_header_chap_last_prop
      {#1} \l_tmpa_tl
      {
        \tl_gset:NV \pnhdchaplast \l_tmpa_tl
        \tl_gset:NV \g_@@_header_prev_last_chap_tl \l_tmpa_tl
      }
      { \tl_gset:NV \pnhdchaplast \g_@@_header_prev_last_chap_tl }
    \prop_get:NnNTF \g_@@_header_sect_first_prop
      {#1} \l_tmpa_tl
      { \tl_gset:NV \pnhdsectfirst \l_tmpa_tl }
      { \tl_gset:NV \pnhdsectfirst \g_@@_header_prev_last_sect_tl }
    \prop_get:NnNTF \g_@@_header_sect_last_prop
      {#1} \l_tmpa_tl
      {
        \tl_gset:NV \pnhdsectlast \l_tmpa_tl
        \tl_gset:NV \g_@@_header_prev_last_sect_tl \l_tmpa_tl
      }
      { \tl_gset:NV \pnhdsectlast \g_@@_header_prev_last_sect_tl }
    \prop_get:NnNTF \g_@@_header_label_first_prop
      {#1} \l_tmpa_tl
      { \tl_gset:NV \pnhdlabelfirst \l_tmpa_tl }
      { \tl_gset:NV \pnhdlabelfirst \g_@@_header_prev_last_label_tl }
    \prop_get:NnNTF \g_@@_header_label_last_prop
      {#1} \l_tmpa_tl
      {
        \tl_gset:NV \pnhdlabellast \l_tmpa_tl
        \tl_gset:NV \g_@@_header_prev_last_label_tl \l_tmpa_tl
      }
      { \tl_gset:NV \pnhdlabellast \g_@@_header_prev_last_label_tl }
    \group_end:
  }
\cs_generate_variant:Nn \@@_set_headers_vars:n { x }

\cs_new_protected:Npn \@@_set_headers_vars_next:
  { \@@_set_headers_vars:x { \int_eval:n { \c@page + 1 } } }

\cs_new_protected:Npn \@@_set_headers_vars_first:
  {
    \@@_set_print_page_label:x { \int_use:N \g_@@_print_postnotes_int }
    \@@_set_headers_vars:x
      {
        \@@_extract_pageref:e
          { print@ \int_use:N \g_@@_print_postnotes_int }
      }
  }

\cs_new_protected:Npn \@@_header_default:
  {
    \tl_if_eq:NNTF \pnhdpagefirst \pnhdpagelast
      { \pnhdnotes{} ~ \pnhdtopage{} ~ \pnhdpagefirst }
      { \pnhdnotes{} ~ \pnhdtopages{} ~ \pnhdpagefirst -- \pnhdpagelast }
  }
\NewDocumentCommand \pnheaderdefault {} { \@@_header_default: }
%    \end{macrocode}
%
%
% \section{Languages}
%
%
%    \begin{macrocode}
% <postnote language><extras>
\cs_new_protected:Npn \@@_define_language:nn #1#2
  {
    \tl_new:c { l_@@_language_extras_ #1 _tl }
    \tl_set:cn { l_@@_language_extras_ #1 _tl } {#2}
  }

% <babel language><postnote language>
\cs_new_protected:Npn \@@_set_babel_language:nn #1#2
  {
    \AddToHook { package/babel/after }
      {
        % I'm using `\tl_gput_right:cn' here since there seems to exist some
        % qualms about `babel's '\addto'.  A number of packages define their
        % own versions of it: varioref (probably the original), backref,
        % cleveref.  The latter comments that `\addto` is "flawed". 'babel'
        % itself comments the definition recognizing that there is an
        % "inconsistency", depending on the case, the operation will be either
        % local or global.  Polyglossia recommends `etoolbox's `\gappto'.  All
        % in all, let's rely on `expl3'.
        \tl_if_exist:cTF { extras #1 }
          {
            \exp_args:Nnv \tl_gput_right:cn { extras #1 }
              { l_@@_language_extras_ #2 _tl }
          }
          {
            \tl_new:c { extras #1 }
            \tl_gset:cv { extras #1 }
              { l_@@_language_extras_ #2 _tl }
          }
      }
  }
% <polyglossia language><postnote language>
\cs_new_protected:Npn \@@_set_polyglossia_language:nn #1#2
  {
    \AddToHook { package/polyglossia/after }
      {
        \exp_args:Ncv \gappto { blockextras@ #1 }
          { l_@@_language_extras_ #2 _tl }
      }
  }
% <babel name of polyglossia variant><postnote language>
\cs_new_protected:Npn \@@_set_polyglossia_variant:nn #1#2
  {
    \AddToHook { package/polyglossia/after }
      {
        \exp_args:Ncv \gappto { blockextras@bbl@ #1 }
          { l_@@_language_extras_ #2 _tl }
      }
  }

\@@_define_language:nn { english }
  {
    \tl_set:Nn \pntitle     { Notes }
    \tl_set:Nn \pnhdnotes   { Notes }
    \tl_set:Nn \pnhdtopage  { to~page }
    \tl_set:Nn \pnhdtopages { to~pages }
  }
\@@_set_babel_language:nn { english }    { english }
\@@_set_babel_language:nn { american }   { english }
\@@_set_babel_language:nn { australian } { english }
\@@_set_babel_language:nn { british }    { english }
\@@_set_babel_language:nn { canadian }   { english }
\@@_set_babel_language:nn { newzealand } { english }
\@@_set_babel_language:nn { UKenglish }  { english }
\@@_set_babel_language:nn { USenglish }  { english }
\@@_set_polyglossia_language:nn { english } { english }

\@@_define_language:nn { portuguese }
  {
    \tl_set:Nn \pntitle     { Notas }
    \tl_set:Nn \pnhdnotes   { Notas }
    \tl_set:Nn \pnhdtopage  { da~página }
    \tl_set:Nn \pnhdtopages { das~páginas }
  }
\@@_set_babel_language:nn { portuguese } { portuguese }
\@@_set_babel_language:nn { brazilian }  { portuguese }
\@@_set_babel_language:nn { portuges }   { portuguese }
\@@_set_babel_language:nn { brazil }     { portuguese }
\@@_set_polyglossia_language:nn { portuguese } { portuguese }
%    \end{macrocode}
%
%
% \section{Compatibility}
%
%
%    \begin{macrocode}
%    \end{macrocode}
%
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
%
% \PrintIndex
%
%
